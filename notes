Future work:
stm32x_conf.h
stm3210x_it.c
stm32_flash.c
change app linker file to 0x08000400
remember to call ISSWRESET in main to distinguish different flow for the programme

array of function pointers to select comm peripheral at runtime
(streams so implemented in ChibiOS)

/*Done
REMEMBER TO DEFINE pFunction TYPE WHEN NOT INCLUDING COMMON.H ANYMORE

/*Done
why in the command go there is an addr+4?
why is dereferencing needed in the jump in the go command?
why __set_MSP(*(uint32_t*) addr);?


/*Done
Issues with mass erase when write unprotect, pages, bla bla bla:
-----
Hi,
Lucky you, we have an internal project that does just this.
(updating protected firmware by bootloader)
The simple way of doing it is to put the bootloader and _only_
the bootloader in the first flash sectors that are write-protected when RDP is ON. 
Then you make sure it does not erase itself.
Meaning you just don't erase the pages containing it. (and of course you don't reprogram it)
So you do NOT need to remove RDP.

Hi,
Let me clarify that there are two possible approaches...
1. Put the bootloader and all the init and libs it requires at the start of flash,
use partial erase, keep RDP active all the time.
In this scheme you cannot upgrade the bootloader itself.
It is quite slow indeed but firmware upgrade is not performed often so 10~20 seconds
delay is usually acceptable. 
2. Remove RDP and reset with boot in RAM.
Then of course you must put in RAM all the init and libs required by the bootloader.
This option is faster to execute (probably) and allows to upgrade the bootloader,
but it is more complex to implement and less secure: if there is a problem (connection, power, etc.)
during the upgrade, you might loose the bootloader and be unable to use the device again
until you reprogram it using a RLink or similar tool.
3. Another posibility would be to go for option 1 for firmware upgrade and for option 2
for bootloader upgrade.


Various trials for reset:
/*__ASM volatile ("      ldr r1, =0xE000ED0C\n\t"
                	"      ldr r0, =0x05FA0004\n\t"
                	"      str r0, [r1, #0]\n\t"
					"self:  b self\n\t"
                	"      bx lr\n\t");
                	*/
	/* Enable write access to IWDG PR, KR. */
	//IWDG->KR = 0x5555;
	/* Clock prescaler setup; 000 is fastest count. */
	//IWDG->PR = 0x0;
	/* Counter startup value kept at default 0xFFF. */
	//IWDG->KR = 0xAAAA;
	/* Launch watchdog. */
	//IWDG->KR = 0xCCCC;
	//uint32_t scbaircr = SCB->AIRCR;
	//__ASM volatile ("SVC 0x0\n\t");
	//NVIC_SystemReset();
	
	void SVC_Handler(void)
{

	//SCB->AIRCR = 0x05FA0004;
	//NVIC_SystemReset();
	/*
	SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
	                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
	                 SCB_AIRCR_SYSRESETREQ_Msk);
	                 */                 /* Keep priority group unchanged */
	//uint32_t reg = 0;
	//reg = SCB->AIRCR;
	//__DSB();                                             /* Ensure completion of memory access */
	//while(1);
}
/* Enable LSI clock generator. */
	RCC->CSR |= 0x1;

	/* Enable independent watchdog clock. */
	RCC->APB1ENR |= 0x800;
	
	
	void ciao() {
	uint32_t pippo1, pippo2;
		pippo1 = (*(__IO uint32_t*)ApplicationAddress);
		pippo2 = pippo1 & 0x2FFE0000;
	    if (pippo2 == 0x20000000)
	    {
	      /* Jump to user application */
	      /* JumpAddress is not a pointer type. */
	      /* ApplicationAddress+4 casted to a pointer to uin32_t. Jump address is the content
	       * of the cell pointed by ApplicationAddress
	       * Though wouldn't this be correct: JumpAddress = ApplicationAddress+4;
	       * or! why does it dereferences it?
	       */
	      JumpAddress = *(__IO uint32_t*) (ApplicationAddress + 4);

	      /*Jump_To_Application now points to the same address = JumpAddress through casting. */
	      Jump_To_Application = (pFunction) JumpAddress;

	      /* Initialize user application's Stack Pointer */
	      /* __set_MSP implemented in CMSIS (as all the functions __* like). */
	      __set_MSP(*(__IO uint32_t*) ApplicationAddress);
	      Jump_To_Application();
	    }
}

/**
  * @brief  Initialize the IAP: Configure RCC, USART and GPIOs.
  * @param  None
  * @retval None
  */

//void IAP_Init(void)
//{
  //USART_InitTypeDef USART_InitStructure;

  /* USART resources configuration (Clock, GPIO pins and USART registers) ----*/
  /* USART configured as follow:
        - BaudRate = 115200 baud  
        - Word Length = 8 Bits
        - One Stop Bit
        - No parity
        - Hardware flow control disabled (RTS and CTS signals)
        - Receive and transmit enabled
  */

  //USART_InitStructure.USART_BaudRate = 115200;
  //USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  //USART_InitStructure.USART_StopBits = USART_StopBits_1;
  //USART_InitStructure.USART_Parity = USART_Parity_No;
  //USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  //USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  //USART_Init(USART1, &USART_InitStructure);

  //STM_EVAL_COMInit(COM1, &USART_InitStructure);
//}

//void IO_Init(void) {

//}


hi


//to obtain 0.7*bitTime = sampleTime set TS1=5 and TS2=2
	uint32_t ts1 = 5;
	uint32_t ts2 = 2;
	uint32_t tot, brp;

	//compute brp
	tot = 1+(ts1+1)+(ts2+1);
	brp = (pclk1)/(tot*canbaud);
